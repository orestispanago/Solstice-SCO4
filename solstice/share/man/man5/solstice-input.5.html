<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>solstice-input(5)</title>
<style type="text/css">
/* Copyright (C) 2016-2018 CNRS
 *
 * This is free style sheet: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This CSS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/. */

body.manpage {
  font-family:"Liberation Sans",sans-serif;
  font-size:10pt;
  text-align: justify;
  max-width: 55em;
  margin: 1em;
  background: #ffffff
}

body.manpage .monospaced, .literalblock {
  margin: 2em;
  color: #636261
}

body.manpage em {
  color: #660000
}

body.manpage div.verseblock > pre.content {
  font-family: "Liberation Mono",monospace;
}

body.manpage h1 {
  padding-bottom: 0.5em;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

body.manpage code {
  font-family: "Liberation Mono",monospace;
}

body.manpage #footer { display: none; }

body.manpage div#toctitle { display: none; }

body.manpage div#toc {
  display: block;
  position:fixed;
  top:0;
  left:60em;
  height:100%;
  width: 100%;
  padding:3em 0 0 0;
  border-left:1px solid #dbdbdb;
  background: #eeeeee
}

body.manpage a {
  font-weight: bold;
  color: #225588;
}

body.manpage div#toc a, div#toc a:link, div#toc a:visited {
  margin:0;
  padding-left: 2em;
  color:#999999;
  text-decoration:none;
  font-weight: normal;
}

body.manpage div.toclevel1 {
  line-height: 1.5em;
}

body.manpage div.toclevel2 {
  margin-left: 2em;
}

body.manpage div#toc a:hover {
  color:#666666;
}

@media print {
  body.manpage div#toc { display: none; }
}



</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
solstice-input(5) Manual Page
</h1>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
<h2>NAME</h2>
<div class="sectionbody">
<p>solstice-input -
   solar plant description for solstice(1)
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <strong>solstice-input</strong> is the format used by the <strong>solstice</strong>(1) program to
represent a solar plant. It relies on the YAML 1.1 data serialization standard
[1]; assuming that the file is compatible with the <strong>solstice-input</strong> semantic, a
solar plant can be described by using the whole YAML 1.1 functionalities
including compact notation and data tagging.</p></div>
<div class="paragraph"><p>A solar plant is composed of a <strong>sun</strong>, an optional <strong>atmosphere</strong> and a collection
of <strong>geometries</strong>, i.e. <strong>shapes</strong> with their associated <strong>material</strong>. Beside the raw
description of the aforementioned data, the <strong>solstice-input</strong> format provides
the <strong>entity</strong> item to efficiently structure the geometries in the scene. An
entity is a node in a tree data structure where the position of each child
entity is relative to the position of its parent. An entity can either
encapsulate a <strong>geometry</strong> or a <strong>pivot</strong> that controls the dynamic positioning of
its child entities with respect to the pivot constraints and the sun direction
submitted to the <strong>solstice</strong>(1) program.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_grammar">GRAMMAR</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content">&lt;solar-plant&gt;         ::= - &lt;sun&gt;
                          - &lt;item&gt;
                        [ - &lt;item&gt; &#8230; ]
                        [ - &lt;atmosphere&gt; ]

&lt;item&gt;                ::= &lt;entity&gt;
                        | &lt;geometry&gt;
                        | &lt;material&gt;
                        | &lt;medium&gt;
                        | &lt;spectrum&gt;
                        | &lt;template&gt;

-------------------------------------

&lt;geometry&gt;            ::= geometry:
                          - &lt;object&gt;
                        [ - &lt;object&gt; &#8230; ]

&lt;object&gt;              ::= &lt;shape&gt;
                          &lt;material&gt;
                        [ &lt;transform&gt; ]

&lt;x_pivot&gt;             ::= x_pivot:
                            &lt;target&gt;
                        [   ref_point: &lt;real3&gt; ] # Default is [0,0,0]

&lt;zx_pivot&gt;            ::= zx_pivot:
                            &lt;target&gt;
                        [   spacing: REAL ] # in [0, INF). Default 0
                        [   ref_point: &lt;real3&gt; ] # Default is [0,0,0]

&lt;target&gt;              ::= target:
                            anchor: &lt;anchor-identifier&gt;
                        |   direction: &lt;real3&gt;
                        |   position: &lt;real3&gt;
                        |   &lt;sun&gt;

-------------------------------------

&lt;shape&gt;               ::= &lt;cuboid&gt;
                        | &lt;cylinder&gt;
                        | &lt;hemisphere&gt;
                        | &lt;hyperbol&gt;
                        | &lt;parabol&gt;
                        | &lt;parabolic-cylinder&gt;
                        | &lt;plane&gt;
                        | &lt;sphere&gt;
                        | &lt;stl&gt;

&lt;cuboid&gt;              ::= cuboid:
                            size: &lt;real3&gt; # in ]0, INF]^3

&lt;cylinder&gt;            ::= cylinder:
                            height: REAL # in ]0, INF)
                            radius: REAL # in ]0, INF)
                        [   slices: INTEGER ] # in [4, 4096]. Default is 16
                        [   stacks: INTEGER ] # in [1, 4096]. Default is 1

&lt;hemisphere&gt;          ::= hemisphere:
                            radius: REAL # in ]0, INF)
                        [   clip: &lt;polyclip-list&gt; ]
                        [   slices: INTEGER ] # in [4, 4096]

&lt;hyperbol&gt;            ::= hyperbol:
                            focals: &lt;hyperboloid-focals&gt;
                            clip: &lt;polyclip-list&gt;
                        [   slices: INTEGER ] # in [4, 4096]

&lt;parabol&gt;             ::= parabol:
                            focal: REAL # in ]0, INF)
                            clip: &lt;polyclip-list&gt;
                        [   slices: INTEGER ] # in [4, 4096]

&lt;parabolic-cylinder&gt;  ::= parabolic-cylinder:
                            focal: REAL # in ]0, INF)
                            clip: &lt;polyclip-list&gt;
                        [   slices: INTEGER ] # in [4, 4096]

&lt;plane&gt;               ::= plane:
                            clip: &lt;polyclip-list&gt;
                        [   slices: INTEGER ] # in [1, 4096]. Default is 1

&lt;sphere&gt;              ::= sphere:
                            radius: REAL # in ]0, INF)
                        [   slices: INTEGER ] # in [4, 4096]. Default is 16
                        [   stacks: INTEGER ] # in [2, 4096]. Default is slices/2

&lt;stl&gt;                 ::= stl:
                            path: PATH

&lt;hyperboloid-focals&gt;  ::= real: REAL # in ]0, INF)
                          image: REAL # in ]0, INF)

----------------------------------------

&lt;polyclip-list&gt;       ::= - &lt;polyclip&gt;
                        [ - &lt;polyclip&gt; &#8230; ]

&lt;polyclip&gt;            ::= operation: &lt;AND|SUB&gt;
                          &lt;contour-descriptor&gt;

&lt;contour-descriptor&gt;  ::= &lt;circle-descriptor&gt;
                        | &lt;vertices-descriptor&gt;

&lt;vertices-descriptor&gt; ::= vertices: &lt;vertices-list&gt;

&lt;circle-descriptor&gt;   ::= circle:
                            radius: REAL # in ]0, INF)
                        [   center: &lt;real2&gt; ] # Default is 0,0
                        [   segments: INTEGER ] # in [3, 4096]. Default is 64

&lt;vertices-list&gt;       ::= - &lt;real2&gt;
                          - &lt;real2&gt;
                          - &lt;real2&gt;
                        [ - &lt;real2&gt; &#8230; ]

----------------------------------------

&lt;material&gt;            ::= material:
                            &lt;material-descriptor&gt;
                        |   &lt;double-sided-mtl&gt;

&lt;double-sided-mtl&gt;    ::= front: &lt;material-descriptor&gt;
                          back: &lt;material-descriptor&gt;

&lt;material-descriptor&gt; ::= &lt;dielectric&gt;
                        | &lt;matte&gt;
                        | &lt;mirror&gt;
                        | &lt;thin-dielectric&gt;
                        | &lt;virtual&gt;

&lt;dielectric&gt;          ::= dielectric:
                            medium_i: &lt;medium-descriptor&gt;
                            medium_t: &lt;medium-descriptor&gt;
                        [   &lt;normal-map&gt; ]

&lt;matte&gt;               ::= matte:
                            reflectivity: &lt;mtl-data&gt; # in [0, 1]
                        [   &lt;normal-map&gt; ]

&lt;mirror&gt;              ::= mirror:
                            reflectivity: &lt;mtl-data&gt; # in [0, 1]
                            slope_error: &lt;mtl-data&gt;
                        [   microfacet: &lt;normal-distrib&gt; ] # Default is BECKMANN
                        [   &lt;normal-map&gt; ]

&lt;normal-distrib&gt;      ::= BECKMANN
                        | PILLBOX

&lt;virtual&gt;             ::= virtual: EMPTY-STRING

&lt;thin-dielectric&gt;     ::= thin_dielectric:
                            thickness: REAL # in [0, INF)
                            medium_i: &lt;medium-descriptor&gt;
                            medium_t: &lt;medium-descriptor&gt;
                        [   &lt;normal-map&gt; ]

&lt;normal-map&gt;          ::= normal_map:
                            path: PATH

----------------------------------------

&lt;medium&gt;              ::= medium: &lt;medium-descriptor&gt;

&lt;medium-descriptor&gt;   ::= refractive_index: &lt;mtl-data&gt; # in ]0, INF)
                          extinction: &lt;mtl-data&gt; # in [0, INF)

----------------------------------------

&lt;entity&gt;              ::= entity: &lt;entity-data&gt;

&lt;template&gt;            ::= template: &lt;entity-data&gt;

&lt;entity-data&gt;         ::= name: STRING
                        [ &lt;geometry-data&gt; | &lt;x_pivot&gt; | &lt;zx_pivot&gt; ]
                        [ &lt;anchors&gt; ]
                        [ &lt;transform&gt; ]
                        [ &lt;children&gt;  ]

&lt;geometry-data&gt;       ::= primary: INTEGER # in [0, 1]
                          &lt;geometry&gt;

&lt;children&gt;            ::= children:
                          - &lt;entity-data&gt;
                        [ - &lt;entity-data&gt; &#8230; ]

&lt;anchors&gt;             ::= anchors:
                          - &lt;anchor-data&gt;
                        [ - &lt;anchor-data&gt; &#8230; ]

&lt;anchor-data&gt;         ::= name: STRING
                          &lt;position-descriptor&gt;

&lt;position-descriptor&gt; ::= position: &lt;real3&gt;
                        | hyperboloid_image_focals: &lt;hyperboloid_focals&gt;

&lt;entity-identifier&gt;   ::= &lt;self|STRING&gt;[.STRING &#8230; ]

&lt;anchor-identifier&gt;   ::= &lt;entity-identifier&gt;.STRING

----------------------------------------

&lt;sun&gt;                 ::= sun:
                            dni: REAL # Direct Normal Irradiance in ]0, INF)
                        [   &lt;spectrum&gt; ] # Default is the smarts295 spectrum
                        [   &lt;sun-shape&gt; ]

&lt;sun-shape&gt;           ::= &lt;pillbox&gt; | &lt;gaussian&gt; | &lt;buie&gt;

&lt;buie&gt;                ::= buie:
                            csr: REAL # in [1e-6, 0.849]

&lt;pillbox&gt;             ::= pillbox:
                            half_angle: REAL # in ]0, 90]

&lt;gaussian&gt;            ::= gaussian:
                            std_dev: REAL # in ]0, INF)

----------------------------------------

&lt;atmosphere&gt;          ::= atmosphere:
                            extinction: &lt;mtl-data&gt; # in [0, 1]

----------------------------------------

&lt;mtl-data&gt;            ::= REAL
                        | &lt;spectrum-data-list&gt;

&lt;transform&gt;           ::= transform:
                            translation: &lt;real3&gt;
                            rotation: &lt;real3&gt;

&lt;real2&gt;               ::= - REAL
                          - REAL

&lt;real3&gt;               ::= - REAL
                          - REAL
                          - REAL

&lt;spectrum&gt;            ::= spectrum: &lt;spectrum-data-list&gt;

&lt;spectrum-data-list&gt;  ::= - &lt;spectrum-data&gt;
                        [ - &lt;spectrum-data&gt; &#8230; ]

&lt;spectrum-data&gt;       ::= wavelength: REAL # in [0, INF)
                          data: REAL # in [0, INF)</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_sun">SUN</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <strong>sun</strong> describes the source of the solar plant. Its direction is not defined
into the <strong>solstice-input</strong>(5) file but is provided by the <strong>solstice</strong>(1) command.
This allows to use the same unmodified <strong>solstice-input</strong>(5) file for several
simulations with different sun directions.</p></div>
<div class="paragraph"><p>The main <strong>sun</strong> property is its direct normal irradiance, or <strong>dni</strong> in W.m^-2.
Its value is a scalar defining the direct irradiance received on a plane
perpendicular to the main sun direction. The optional <strong>spectrum</strong> parameter
describes the per wavelength distribution of the sun <strong>dni</strong>. Note that this
distribution is automatically normalized by <strong>solstice</strong>(1). If the <strong>spectrum</strong>
attribute is not defined, <strong>solstice</strong>(1) uses a default spectrum computed with
the SMARTS software [2] between 0.28 and 4 micro-meters. The total <strong>dni</strong>
(integrated over the spectral range) was set to 1000 W.m^-2. The standard
Mid-Latitude-Summer atmosphere was used with most of gases concentration set
as default (the CO2 concentration was assumed 400ppmv in the atmosphere
column).</p></div>
<div class="paragraph"><p>Even if an atmosphere is provided, the atmospheric effects from the top of the
atmosphere to ground level are not computed using the atmosphere description.
As a result, the sun description (<strong>dni</strong> and optional <strong>spectrum</strong>) is expected to
include all the atmospheric effects (sun irradiance available at ground
level).</p></div>
<div class="paragraph"><p>The <strong>sun-shape</strong> parameter controls the angular distribution of the sun light
intensity across the sun&#8217;s disk. If not defined, the distribution is assumed to
be a dirac distribution (infinite directional source). The available sun
shapes are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>pillbox</strong>
</dt>
<dd>
<p>
  The <strong>pillbox</strong> distribution defines an uniform intensity over the sun&#8217;s disk.
  Its single <strong>half_angle</strong> parameter is the sun&#8217;s disk half-angle in degrees, that
  is linked to the apparent size of the sun. A typical half_angle is 0.2664.
</p>
</dd>
<dt class="hdlist1">
<strong>gaussian</strong>
</dt>
<dd>
<p>
  The <strong>gaussian</strong> distribution defines a gaussian distribution of the solar
  incoming direction. Its single <strong>std_dev</strong> parameter is the standard deviation
  of the distribution in degrees. Values around 0.2 are typical.
  As the gaussian distribution is not truncated, the resulting sun vector can
  theoreticaly be oriented towards the sun, especially with a big, non-typical
  <strong>std_dev</strong> value.
</p>
</dd>
<dt class="hdlist1">
<strong>buie</strong>
</dt>
<dd>
<p>
  The <strong>buie</strong> distribution, as first discribed in [3]. Its single <strong>csr</strong>
  parameter is the ratio between the circumsolar irradiance and the sum of
  the circumsolar and sun&#8217;s disk irradiance. An analysis on typical <strong>csr</strong>
  values can be found in [4].
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_atmosphere">ATMOSPHERE</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <strong>atmosphere</strong>, when provided, describes the medium surrounding the
solar plant. Its only parameter is its extinction coefficient in m^-1, that
can either be a scalar if the <strong>extinction</strong> is constant over the spectrum, or
can be spectrally described. The extinction along light paths is only computed
after the first reflector, as sun description must include all the atmospheric
effects before the first reflector (see sun description for more details).</p></div>
<div class="paragraph"><p>If no atmosphere is provided, atmospheric extinction after the first reflector
is not taken into account.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_material">MATERIAL</h2>
<div class="sectionbody">
<div class="paragraph"><p>A <strong>material</strong> describes the properties of an interface. These properties can be
the same for the two sides of the interface or may be differentiated with a
<strong>double-sided-mtl</strong>. The material comportment is controlled by a
<strong>material-descriptor</strong> that specifies the physical properties of the interface
as well as its optional normal perturbation. Note that the physical properties
can be either scalars or spectral data.</p></div>
<div class="sect2">
<h3 id="_material_descriptors">Material descriptors</h3>
<div class="paragraph"><p>The available material descriptors are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>dielectric</strong>
</dt>
<dd>
<p>
Interface between 2 dielectric media. Its <strong>medium_i</strong> parameter defines the
current medium, i.e. the medium the ray travels in, while <strong>medium_t</strong>
represents the opposite medium. Incoming rays are either specularly reflected
or refracted according to a Fresnel term computed with respect to the
refractive indices of the 2 media as:
</p>
<div class="literalblock">
<div class="content">
<pre><code>Fr = 1/2 * (Rs^2 + Rp^2)</code></pre>
</div></div>
<div class="paragraph"><p>with Rs and Rp the reflectance for the light polarized with its electric
field perpendicular or parallel to the plane of incidence, respectively.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Rs = (n1 * |wi.N| - n2 * |wt.N|) / (n1 * |wi.N| + n2 * |wt.N|)
Rp = (n2 * |wi.N| - n1 * |wt.N|) / (n2 * |wi.N| + n1 * |wt.N|)</code></pre>
</div></div>
<div class="paragraph"><p>with n1 and n2 the indices of refraction of the incident and transmitted
media, and wi and wt the incident and transmitted direction.</p></div>
<div class="paragraph"><p>Be careful to ensure the media consistency in the <strong>solstice-input</strong>(5) file; a
ray travelling in a medium <em>A</em> can only encounter a medium interface whose
<strong>medium_i</strong> attribute is <em>A</em>. Consequently, a <strong>dielectric</strong> material must be
defined as a double sided material whose front and back interfaces are
dielectrics with inverted media:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>material:
  front:
    dielectric:
      medium_i: &amp;vacuum { refractive_index: 1, extinction: 0 }
      medium_t: &amp;glass { refractive_index: 1.5, extinction: 20 }
  back:
    dielectric:
      medium_i: *glass
      medium_t: *vacuum</code></pre>
</div></div>
<div class="paragraph"><p>If the media consistency is not ensured, <strong>solstice</strong>(1) will fail to run
simulations. Note that by default, the surrounding medium is assumed to be
the vacuum, i.e.  its refractive index and its extinction are scalars whose
values are 1 and 0, respectively. If an atmosphere is defined, the refractive
index of the surrounding medium is still the scalar 1 but its extinction is
the one of the atmosphere. In other words, to reference the surrounding medium
in the <strong>medium_i</strong> or the <strong>medium_t</strong> attribute of a <strong>dielectric</strong> interface, one
has to define a medium whose refractive index is the scalar 1 and extinction
is either 0 or the extinction of the atmosphere if the latter is defined or
not, respectively.</p></div>
</dd>
<dt class="hdlist1">
<strong>matte</strong>
</dt>
<dd>
<p>
Diffuse surface. Reflects the same intensity in all directions independently
of the incoming direction.
</p>
</dd>
<dt class="hdlist1">
<strong>mirror</strong>
</dt>
<dd>
<p>
Specular or glossy reflection whether the <strong>slope_error</strong> parameter is 0 or not,
respectively. Glossy reflections are controlled by a microfacet BRDF. The
microfacet normals are distributed with respect to the Beckmann or the Pillbox
distribution according to the <strong>normal-distrib</strong> attribute.
</p>
<div class="paragraph"><p>Let S the <strong>slope_error</strong> parameter in ]0, 1]. The Beckmann distribution is
defined as:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>D(wh) = exp(-tan^2(a) / m^2) / (PI * m^2 * cos^4(a))</code></pre>
</div></div>
<div class="paragraph"><p>with a = arccos(wh.N), and m = sqrt(2)*S while the pillbox distribution is
defined as:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>        | 0; if |wh.N| &gt;= S
D(wh) = |
        | 1 / (PI * (1 - cos^2(S))); if |wh.N| &lt; S</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
<strong>thin-dielectric</strong>
</dt>
<dd>
<p>
The interface is assumed to be a thin slab of a dielectric material. The
<strong>medium_i</strong> parameter defines the outside dielectric medium while <strong>medium_t</strong>
is the medium of the thin slab. Incoming rays are either specularly reflected
or transmitted (without deviation) according to a Fresnel term computed with
respect to the refractive indices of the 2 media as:
</p>
<div class="literalblock">
<div class="content">
<pre><code>Fr = 1/2 * (Rs^2 + Rp^2)</code></pre>
</div></div>
<div class="paragraph"><p>with Rs and Rp the reflectance for the light polarized with its electric
field perpendicular or parallel to the plane of incidence, respectively.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Rs = (n1 * |wi.N| - n2 * |wt.N|) / (n1 * |wi.N| + n2 * |wt.N|)
Rp = (n2 * |wi.N| - n1 * |wt.N|) / (n2 * |wi.N| + n1 * |wt.N|)</code></pre>
</div></div>
<div class="paragraph"><p>with n1 and n2 the indices of refraction of the incident and transmitted
media, and wi and wt the incident and transmitted direction. Note that the
underlying scattering function correctly handles the multiple refraction
effects into the thin slab.</p></div>
<div class="paragraph"><p>Be careful to ensure the media consistency in the <strong>solstice-input</strong>(5) file; a
ray travelling in a medium <em>A</em> can only encounter a medium interface whose
<strong>medium_i</strong> attribute is <em>A</em>. If the media consistency is not ensured,
<strong>solstice</strong>(1) will fail to run simulations. Note that by default, the
surrounding medium is assumed to be the vacuum, i.e. its refractive index and
its extinction are scalars whose values are 1 and 0, respectively. If an
atmosphere is defined, the refractive index of the surrounding medium is still
the scalar 1 but its extinction is the one of the atmosphere. In other words,
to reference the surrounding medium in the <strong>medium_i</strong> attribute of a
<strong>thin-dielectric</strong> interface, one has to define a medium whose refractive
index is the scalar 1 and extinction is either 0 or the extinction of the
atmosphere if the latter is defined.</p></div>
</dd>
<dt class="hdlist1">
<strong>virtual</strong>
</dt>
<dd>
<p>
Fully transparent interface.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_normal_map">Normal map</h3>
<div class="paragraph"><p>All the material descriptors, excepted the <strong>virtual</strong>, provide an optional
<strong>normal-map</strong> attribute that defines a path toward a Portable PixMap image [5]
whose pixels store a normal expressed in the tangent space of the interface. By
default the unperturbed tangent space normal is {0,0,1}. The PPM image can
be encoded on 8 or 16-bits per component either in ASCII or binary. The
parameterization of this 2D image onto the shape surfaces depends on the type
of the shape. For the <strong>hemisphere</strong>, <strong>hyperbol</strong>, <strong>parabol</strong>, <strong>plane</strong> and
<strong>parabolic-cylinder</strong> shapes, the image is mapped in the {X,Y} plane. The other
shapes are not parameterized and consequently, applying a normal-mapped
material on these shapes leads to undefined behaviors.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_shape">SHAPE</h2>
<div class="sectionbody">
<div class="paragraph"><p>A <strong>shape</strong> describes a geometric model. It is defined in its local space, i.e.
in a coordinate system whose origin is proper to the shape. No space
transformation can be introduced through the declaration of a shape: it should
be transformed externally through an <strong>object</strong> and/or <strong>entities</strong>.
<strong>solstice-input</strong>(1) provides 2 types of shape: quadric and mesh. The former is
used to declare parametric surfaces, while the latter describes triangulated
surfaces.</p></div>
<div class="sect2">
<h3 id="_quadric">Quadric</h3>
<div class="paragraph"><p>A quadric shape is defined from a quadric equation and a set of 2D clipping
operations performed in their {X,Y} plane. By convention, the front side of the
quadric surface looks toward the positive Z axis. Internally, the clipped
quadric surface is discretized in a triangular mesh with respect to the
discretisation parameters of the quadric. This mesh is used by <strong>solstice</strong>(1)
as a "proxy" to speed up the access toward the quadric shape: the quadric
position and its associated normal are in fine computed from the quadric
equation.</p></div>
<div class="paragraph"><p>The quadric surface is parameterized in the {X,Y} plane. Its parameterization
domain is defined from the bounds of its clipped mesh in the {X,Y} plane:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>u = (x - lowerX) / (upperX-lowerX)
v = (y - lowerY) / (upperY-lowerY)</code></pre>
</div></div>
<div class="paragraph"><p>with <strong>u</strong> and <strong>v</strong> the mapped 2D coordinates from a 3D position {<strong>x</strong>,<strong>y</strong>,<strong>z</strong>}
onto the quadric, and <strong>lower</strong>&lt;<strong>X</strong>|<strong>Y</strong>&gt; and <strong>upper</strong>&lt;<strong>X</strong>|<strong>Y</strong>&gt; the lower
and upper bounds of the clipped quadric along the X and Y axis. The available
quadrics are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>hemisphere</strong>
</dt>
<dd>
<p>
Hemispheric shape defined along the Z axis whose minimum is positioned at
the origin. The <strong>slices</strong> parameter controls the number of divisions along
the Z axis.
</p>
<div class="literalblock">
<div class="content">
<pre><code>x^2 + y^2 + (z-radius)^2 = radius^2</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
<strong>hyperbol</strong>
</dt>
<dd>
<p>
Hyperbolic quadric defined along the Z axis whose minimum is positioned at
the origin. The <strong>slices</strong> parameter controls the discretisation of the
hyperbol. If not defined, it is automatically computed with respect to the
hyperbol curvature.
</p>
<div class="literalblock">
<div class="content">
<pre><code>(x^2 + y^2) / a^2 - (z + z0 - g/2)^2 / b^2 + 1 = 0

a^2 = g^2(f - f^2)
b = g(f - 1/2)
z0 = |b| + g/2
g = focals.real + focals.image
f = focals.real / g</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
<strong>parabol</strong>
</dt>
<dd>
<p>
Parabolic quadric defined along the Z axis whose minimum is positioned at the
origin. The <strong>slices</strong> parameter controls the discretisation of the parabol. If
not defined, it is automatically computed with respect to the parabol
curvature.
</p>
<div class="literalblock">
<div class="content">
<pre><code>x^2 + y^2 - 4 * focal * z = 0</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
<strong>parabolic-cylinder</strong>
</dt>
<dd>
<p>
Parabolic cylinder oriented along the Z axis whose main axis is along the X
axis and minimum is positioned at the origin. The <strong>slices</strong> parameter
controls the discretisation of the parabolic cylinder. If not defined, it is
automatically computed with respect to the parabolic cylinder curvature.
</p>
<div class="literalblock">
<div class="content">
<pre><code>y^2 - 4 * focal * z = 0</code></pre>
</div></div>
</dd>
<dt class="hdlist1">
<strong>plane</strong>
</dt>
<dd>
<p>
Plane whose normal points along the positive Z axis. The <strong>slices</strong> attribute
controls the discretisation of the clipped plane.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_clipping">Clipping</h3>
<div class="paragraph"><p>A clipping operation, or <strong>polyclip</strong>, is used to remove some parts of the
quadric surface. It is defined by a 2D <strong>contour-descriptor</strong> expressed in the
{X,Y} plane and a clipping <strong>operation</strong>. The <strong>AND</strong> and <strong>SUB</strong> clip operands,
remove the quadric surface that intersects or does not intersect the
<strong>contour-descriptor</strong>, respectively. The available <strong>countour-descriptors</strong> are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>circle-descriptor</strong>
</dt>
<dd>
<p>
Circular contour whose size is defined by the <strong>radius</strong> parameter. Actually,
<strong>solstice</strong>(1) discretized the circular contour with respect to the <strong>segments</strong>
attribute that defines the overall number of segments used to approximate the
circle.
</p>
</dd>
<dt class="hdlist1">
<strong>vertices-descriptor</strong>
</dt>
<dd>
<p>
Polygonal contour described by a list of 2D vertices. The polygon edges are
defined by connecting each vertex to its previous one. To ensure that the
polygon is closed, an additional edge is automatically created between the
first and the last vertex.  Note that <strong>solstice</strong>(1) assumes that the defined
polygon does not overlap itself, i.e. their non consecutive edges are not
intersecting.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The <strong>clip</strong> parameter of the quadrics lists a set of the aforementioned 2D
<strong>polyclips</strong>. Each of these clipping operations is successively applied on the
remaining quadric surface, in the order on which they are declared. For
instance, the following example uses 5 clipping operations on a plane to build
a rectangle with a circular hole at each of its corner. The first <strong>polyclip</strong>
limits the infinite plane to a rectangle centered in 0 whose size in X and Y is
8 and 4, respectively. The 4 subsequent <strong>polyclips</strong> drill the
rectangle near of its corner with circles whose radius is 0.5:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>plane:
  clip:
  - {operation: AND, vertices: [[-4,-2],[-4,2],[4,2],[4,-2]]}
  - {operation: SUB, circle: {radius: 0.5, center: [-3,-1]}}
  - {operation: SUB, circle: {radius: 0.5, center: [-3, 1]}}
  - {operation: SUB, circle: {radius: 0.5, center: [ 3,-1]}}
  - {operation: SUB, circle: {radius: 0.5, center: [ 3, 1]}}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_triangular_mesh">Triangular mesh</h3>
<div class="paragraph"><p>Triangular meshes are generated by <strong>solstice</strong>(1) from a shape description or
loaded from a CAO file. Their normals are defined per triangle and are thus
discontinuous even for smooth shapes as spheres. The triangular meshes are not
parameterized, i.e. they do not provide a mapping from a 3D position onto its
surface to a 2D coordinates. Applying a normal-mapped material to a triangular
mesh will thus produce undefined behaviors.</p></div>
<div class="paragraph"><p>The available triangular meshes are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>cuboid</strong>
</dt>
<dd>
<p>
  Axis aligned cuboid centered in 0 whose corner positions and dimensions along
  the 3 axis are defined by the <strong>size</strong> parameter. The front side of the cuboid
  surface looks outside the cuboid.
</p>
</dd>
<dt class="hdlist1">
<strong>cylinder</strong>
</dt>
<dd>
<p>
  Cylinder centered in 0 whose <strong>height</strong> is along the positive Z axis. The top
  and the bottom of the cylinder is capped. The <strong>stacks</strong> and <strong>slices</strong>
  parameters control the discretisation, i.e. the number of divisions, along or
  around the Z axis, respectively. The front side of the cylinder surface looks
  outside the cylinder.
</p>
</dd>
<dt class="hdlist1">
<strong>sphere</strong>
</dt>
<dd>
<p>
  Triangulated sphere centered in 0. The <strong>stacks</strong> and <strong>slices</strong> parameters
  control the discretisation, i.e. the number of divisions, along or around the
  Z axis, respectively. The front side of the sphere surface looks outside the
  sphere.
</p>
</dd>
<dt class="hdlist1">
<strong>stl</strong>
</dt>
<dd>
<p>
  Path toward an external mesh file defined with respect to the ASCII
  <strong>ST</strong>ereo <strong>L</strong>ithography file format. The front side of the loaded
  triangles is defined with respect to their vertex ordering into the STL
  file: a triangle is front facing when their vertices are clock wise ordered.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_entity">ENTITY</h2>
<div class="sectionbody">
<div class="paragraph"><p>An <strong>entity</strong> is used to declare and position shapes into the solar plant.
Actually, the entity is the only item that effectively spawns a <strong>geometry</strong> into
the solar plant: if a geometry is declared but not referenced by an entity, it
is ignored by <strong>solstice</strong>(1). An entity is a hierarchical data structure that
can have child entities whose transformation is relative to their parent. If
not defined, the <strong>transform</strong> parameter of an entity is assumed to be the
identity, i.e. its <strong>rotation</strong> and <strong>translation</strong> are nulls.</p></div>
<div class="paragraph"><p>Each entity has a <strong>name</strong> which must be unique per hierarchy level: 2 root
entities (i.e. entities without parent) cannot have the same name as well as
the children of a same parent entity. In addition, the name string cannot
contain dots, spaces or tabulations. A child entity is identified into the
solar plant by successively concatenating, with the '.' character, the name
of its ancestors with its own name. This naming convention is used in the
<strong>solstice-receiver</strong>(5) format to define the entities to track during the
<strong>solstice</strong>(1) computations. For instance, in the following example, the
<strong>entity-identifier</strong> of the child entity named <strong>level2</strong> is
<strong>level0.level1.level2</strong>:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>entity:
  name: level0
  child:
  - name: level1
    child:
    - name: level2</code></pre>
</div></div>
<div class="paragraph"><p>An entity encapsulates either a <strong>geometry</strong> or a <strong>pivot</strong>. The former is a
collection of <strong>objects</strong>, i.e. <strong>shapes</strong> with their associated <strong>material</strong> and an
optional <strong>transformation</strong>. The latter is used to control the dynamic
positioning of the child entities with respect to some constraints defined by
the pivot type, and the sun directions submitted by <strong>solstice</strong>(1). Each entity
can also have a list of <strong>anchors</strong>. An anchor is used to define a position
relative to the entity into which it is declared.</p></div>
<div class="paragraph"><p>For a geometric entity one has to define if the encapsulated geometry is a
<strong>primary</strong> geometry, i.e. a geometry directly lit by the sun and used to
concentrate the solar flux (e.g. a primary mirror). One can define all the
solar plant geometric entities as primaries but a well designed solar plant
with correctly tagged primary geometries will drastically improve the
convergence speed of the <strong>solstice</strong>(1) simulations.</p></div>
<div class="sect2">
<h3 id="_template">Template</h3>
<div class="paragraph"><p>A <strong>template</strong> is a first level entity with no existence into the solar plant. It
is used to pre-declare an entity hierarchy that can then be instantiated
several times in the solar plant by referencing it through common entities with
YAML data tagging. In the following example, the templated entity <strong>my-template</strong>
is instantiated 3 times into the scene:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- template: &amp;my-template
    name: bar
    primary: 1
    geometry: ...
- entity:
    name: foo0
    transform: {translation: [-10.5, 0, 0]}
    children: [*my-template]
- entity:
    name: foo1
    transform: {translation: [0, 0, 0]}
    children: [*my-template]
- entity:
    name: foo2
    transform: {translation: [10.5, 0, 0]}
    children: [*my-template]</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_pivot">Pivot</h3>
<div class="paragraph"><p>A <strong>pivot</strong> is a special kind of node that can be used in the tree data
structure describing an entity to automatically point its child geometry
according to the sun position and to the pivot parameters. It is supposed (but
not mandatory) that the children of a pivot includes a reflector, that,
once pivoted, will reflect the sun light towards a <strong>target</strong>. You should
note that a pivot cannot be the child of another pivot.</p></div>
<div class="paragraph"><p>The most noticeable pivot parameter is its <strong>target</strong>. Four different types of
targets are available:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>position</strong>
</dt>
<dd>
<p>
  Define the target as being an absolute point in world coordinates.
</p>
</dd>
<dt class="hdlist1">
<strong>anchor</strong>
</dt>
<dd>
<p>
  Define the target as being a position relative to an entity (see the
  <strong>anchor</strong> section).
</p>
</dd>
<dt class="hdlist1">
<strong>sun</strong>
</dt>
<dd>
<p>
  Define the target as being the center of the sun.
</p>
</dd>
<dt class="hdlist1">
<strong>direction</strong>
</dt>
<dd>
<p>
  The pivot reflects light in the given direction, specified in world
  coordinates.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Pivots can also have a <strong>ref_point</strong> optional parameter defining a 3D point in
the coordinate system the pivot children that will be used by the pointing algorithm.
If not provided, it is set to the origin.</p></div>
<div class="paragraph"><p>Two different flavours of <strong>pivots</strong> are available: <strong>x_pivot</strong> and <strong>zx_pivot</strong>,
each with its own set of parameters and behaviour.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>x_pivot</strong>
</dt>
<dd>
<p>
  Pivot with a single rotation axis: the +X axis in its local coordinate
  system. It has a <strong>target</strong> and can have a <strong>ref_point</strong>. Its pointing algorithm
  considers an incoming ray of light from the center of the sun and rotates
  its children so that a specular reflection at <strong>ref_point</strong> using +Z as
  local normal will hit the target point of the pivot, or will have the
  specified direction (depending of the kind of target).
</p>
</dd>
<dt class="hdlist1">
<strong>zx_pivot</strong>
</dt>
<dd>
<p>
  Pivot with two rotation axis: the +Z axis in its local coordinate system,
  then the +X axis in the coordinate system resulting of the Z rotation.
  It has a <strong>target</strong> and can have a <strong>ref_point</strong> and a <strong>spacing</strong> that defines
  the translation along the +Y axis after the first rotation. If not
  defined, <strong>spacing</strong> is 0. The <strong>zx_pivot</strong> pointing algorithm considers an
  incoming ray of light from the center of the sun and rotates its
  children so that a specular reflection at <strong>ref_point</strong> using
  +Y as local normal will hit the target point of the pivot, or will have
  the specified direction (depending of the kind of target).
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_anchor">Anchor</h3>
<div class="paragraph"><p>An <strong>anchor</strong> defines a relative position into the entity hierarchy. They are
particularly useful for pivots and hyperbolic shapes that may have to
reference a position relative to an entity whose transformations may also
depends of its ancestor. An anchor has a <strong>name</strong> that must be unique for the
whole sets of per entity anchors. In addition, a name cannot contain
dots, spaces or tabulations. An anchor is identified into the solar plant by
concatenating, with the '.' character, its name to the <strong>entity-identifier</strong> of
the entity into which it is declared. For instance, in the following example,
the <strong>anchor-identifier</strong> of the anchor named <strong>anchor0</strong> is
<strong>level0.level1.anchor0</strong>:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>entity:
  name: level0
  child:
  - name: level1
    anchor:
    - {name: anchor0, position: [0, 0, 0]}
    - {name: anchor1, position: [1, 2, 3]}</code></pre>
</div></div>
<div class="paragraph"><p>In some situations, the <strong>anchor-identifier</strong> cannot be fully determined. Let a
templated entity with a descendant referencing an anchor of one of its
ancestors. On its declaration, the template is still not instantiated through a
parent entity and consequently the name of the root entity is unknown.
Moreover, the name of the root entity cannot be fixed since it changes for each
instance of the template. To handle these cases, the <strong>self</strong> reserved keyword
allows to reference the unknown root entity of the currently declared
hierarchy. In the following example, the entities <strong>entity0.level0.level1</strong> and
<strong>entity1.level0.level1</strong> encapsulate a pivot that references the anchor
<strong>anchor0</strong> defined in their respective parent <strong>entity0.level0</strong> and
<strong>entity1.level0</strong>:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- template: &amp;my-template
    name: level0
    anchor: [{name: anchor0, position: [1, 2, 3]}]
    child:
    - name: level1
      pivot:
        x_pivot:
          ref_point: {0, 0, 0}
          target: {anchor: self.level0.anchor0}

- entity: {name: entity0, child: [*my-template]}
- entity: {name: entity1, child: [*my-template]}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_transform">Transform</h3>
<div class="paragraph"><p>A <strong>transform</strong> is used to move an <strong>object</strong> or an <strong>entity</strong> in space. The
<strong>rotation</strong> parameter list 3 angles in degrees defining the rotation to perform
around the X, Y and Z axis. The <strong>translation</strong> attribute describes the offsets
to apply along the X, Y and Z axis. Let the local repair <strong>p</strong> of an object, <strong>p</strong>
is transformed in <strong>p'</strong> with respect to its associated <strong>transform</strong> as follow:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>p' = Rx * Ry * Rz * (T + p)</code></pre>
</div></div>
<div class="paragraph"><p>with <strong>T</strong> the translation vector and <strong>Rx</strong>, <strong>Ry</strong> and <strong>Rz</strong> the rotation matrices
around the X, Y and Z axis defined as:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>     | 1  0   0 |        | cY  0 sY |        | cZ -sZ  0 |
Rx = | 0 cX -sX |;  Ry = |  0  1  0 |;  Rz = | sZ  cZ  0 |
     | 0 sX  cX |        |-sY  0 cY |        |  0   0  1 |</code></pre>
</div></div>
<div class="paragraph"><p>where <strong>c</strong>&lt;<strong>X</strong>|<strong>Y</strong>|<strong>Z</strong>&gt; and <strong>s</strong>&lt;<strong>X</strong>|<strong>Y</strong>|<strong>Z</strong>&gt; are the cosine and the
sinus, respectively, of the rotation angles around the X, Y and Z axis.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">EXAMPLES</h2>
<div class="sectionbody">
<div class="paragraph"><p>Declare 2 entities and a point source sun. The first entity is a purely
specular square of size 10, whose center is at the origin. The second entity
is a purely transparent square used as a receiver of the solar flux. Its size
is 1 and its center is positioned at {0,0,2}:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- sun: {dni: 1000}

- entity:
    name: reflector
    primary: 1
    geometry:
    - material:
        mirror:
          reflectivity: 1
          slope_error: 0
      plane:
        clip:
        - operation: AND
          vertices:
          - [-5.0,-5.0]
          - [-5.0, 5.0]
          - [ 5.0, 5.0]
          - [ 5.0,-5.0]

- entity:
    name: receiver
    primary: 0
    transform:
      translation: [0, 0, 2]
    geometry:
    - material:
        virtual: # No attrib
      plane:
        clip:
        - operation: AND
          vertices:
          - [-0.5,-0.5]
          - [-0.5, 0.5]
          - [ 0.5, 0.5]
          - [ 0.5,-0.5]</code></pre>
</div></div>
<div class="paragraph"><p>Define a circular diffuse reflector surrounded by a virtual sphere and a
pillbox-shaped sun whose <strong>half_angle</strong> is 0.1 degree. Use anchors and tags of the
YAML format to reference into the entities a pre-declared geometry. Rely on
the YAML compact notation to reduce the number of lines required to describe
the scene:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- sun: {dni: 1000, pillbox: {half_angle: 0.1}}

- geometry: &amp;small-circle
  - material: {matte: {reflectivity: 1}}
    plane: {clip: [{operation: AND, circle: {radius: 0.5}}]}

- geometry: &amp;big-sphere
  - material: {?virtual}
    sphere: {radius: 2, slices: 128}

- entity: {name: reflector, primary: 1, geometry: *small-circle}
- entity: {name: receiver,  primary: 0, geometry: *big-sphere}</code></pre>
</div></div>
<div class="paragraph"><p>Declare 2 parabolic reflectors from a <strong>templated</strong> parabola whose orientation is
controlled by a <strong>zx_pivot</strong>. This pivot ensures that the reflector points toward
the receiver, independently of its position, by targeting an <strong>anchor</strong> whose
position is defined relatively to the receiver:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- sun: {dni: 1000}

- entity: # Receiver
    name: square_receiver
    primary: 0
    transform: { rotation: [0,90,0], translation: [100,0,10] }
    anchors: [{name: anchor0, position: [0,0,0]}]
    geometry:
    - material: {?virtual}
      plane:
        clip:
        - operation: AND
          vertices: [[-.5,-.5],[-.5,.5],[.5,.5],[.5,-.5]]

- template: &amp;self_oriented_parabol # Reflector
    name: pivot
    transform: {translation: [0, 0, 4], rotation: [0, 0, 90]}
    zx_pivot: {target: {anchor: square_receiver.anchor0}}
    children:
    - name: parabol
      transform: {rotation: [-90, 0, 0]}
      primary: 1
      geometry:
      - material: {mirror: {reflectivity: 1, slope_error: 0}}
        parabol:
          focal: 100
          clip:
          - operation: AND
            vertices: [[-5,-5],[-5,5],[5,5],[5,-5]]

# Instantiate the reflector template
- entity:
    name: reflector1
    transform: {translation: [0,0,0]}
    children: [*self_oriented_parabol]
- entity:
    name: reflector2
    transform: {translation: [10,43.6,0]}
    children: [*self_oriented_parabol]</code></pre>
</div></div>
<div class="paragraph"><p>Declare a solar furnace with 9 heliostats instantiated from the same
<strong>template</strong>. Their position is controlled by a <strong>zx_pivot</strong> to ensure that the
incoming sun rays are reflected toward the negative X axis. Reflected rays are
then concentrated by a parabola toward a purely absorptive receiver. The
heliostats and the parabola share the same material: the front faces are
purely specular while the back faces are diffuse:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>- sun: {dni: 1000}

- material: &amp;specular
    front: {mirror: {reflectivity: 1, slope_error: 0}}
    back: {matte: {reflectivity: 1}}

- template: &amp;H # Template of an heliostat
    name: heliostat
    transform: {translation: [0,0,5.5]}
    zx_pivot: {target: {direction: [-1,0,0]}}
    children:
    - name: reflector
      transform: {rotation: [-90,0,0]}
      primary: 1
      geometry:
      - material: *specular
        plane:
          clip: [{operation: AND, vertices: [[-5,-5],[-5,5],[5,5],[5,-5]]}]

- entity: # Receiver entity
    name: receiver
    primary: 0
    transform: {translation: [18,0,20], rotation: [0,90,0]}
    geometry:
    - material: {matte: {reflectivity: 0}}
      plane:
        clip:
        - operation: AND
          vertices: [[-.5,-.5],[-.5,.5],[.5,.5],[.5,-.5]]

- entity: # Great parabola
    name: parabola
    primary: 0
    transform: {translation: [0,0,20], rotation: [0,90,90]}
    geometry:
    - material: *specular
      parabol:
        focal: 18
        clip: [{operation: AND, vertices: [[-30,-20],[-30,20],[30,20],[30,-20]]}]

# Instantiate the heliostat template
- entity: {name: H1, children: [*H], transform: {translation: [40,-20, 0]}}
- entity: {name: H2, children: [*H], transform: {translation: [40,  0, 0]}}
- entity: {name: H3, children: [*H], transform: {translation: [40, 20, 0]}}
- entity: {name: H4, children: [*H], transform: {translation: [60,-20,10]}}
- entity: {name: H5, children: [*H], transform: {translation: [60,  0,10]}}
- entity: {name: H6, children: [*H], transform: {translation: [60, 20,10]}}
- entity: {name: H7, children: [*H], transform: {translation: [80,-20,20]}}
- entity: {name: H8, children: [*H], transform: {translation: [80, 0, 20]}}
- entity: {name: H9, children: [*H], transform: {translation: [80, 20,20]}}</code></pre>
</div></div>
<div class="paragraph"><p>This example illustrates the use of quadrics and refractive materials: in this
example, three partial <strong>parabols</strong> with various focal distances and positions
concentrate incoming radiation at a common focal position. But a <strong>hyperbol</strong> is
located between the parabols and their common focal position, which is also
one of the two focals of the hyperbol. Radiation is therefore redirected to
the second focal of the hyperbol, where the square target is located. Finally,
a <strong>cuboid</strong> using a glass material is located between the hyperbol and the
target. In this example, a small fraction of incoming power is absorbed by the
target. The rest is either missing the target, absorbed or refracted by the
glass. Furthermore, this example illustrates the use of a <strong>spectrum</strong> for
<strong>refractive index</strong> and <strong>extinction</strong> by various <strong>media</strong> (air and glass).</p></div>
<div class="literalblock">
<div class="content">
<pre><code># Spectra
- spectrum: &amp;solar_spectrum
  - {wavelength: 0.3, data: 1.0}
  - {wavelength: 0.4, data: 2.0}
  - {wavelength: 0.5, data: 0.5}
  - {wavelength: 0.6, data: 3.5}
  - {wavelength: 0.7, data: 1.5}
  - {wavelength: 0.8, data: 0.8}

- spectrum: &amp;air_kabs
  - {wavelength: 0.3, data: 1.0e-4}
  - {wavelength: 0.4, data: 1.0e-5}
  - {wavelength: 0.5, data: 2.0e-5}
  - {wavelength: 0.6, data: 2.0e-4}
  - {wavelength: 0.7, data: 3.0e-5}
  - {wavelength: 0.8, data: 1.0e-4}

- spectrum: &amp;glass_kabs
  - {wavelength: 0.3, data: 1.0e-2}
  - {wavelength: 0.4, data: 1.0e-3}
  - {wavelength: 0.5, data: 2.0e-3}
  - {wavelength: 0.6, data: 2.0e-2}
  - {wavelength: 0.7, data: 3.0e-3}
  - {wavelength: 0.8, data: 1.0e-3}

- spectrum: &amp;glass_ref_index
  - {wavelength: 0.30, data: 1.40}
  - {wavelength: 0.40, data: 1.39}
  - {wavelength: 0.50, data: 1.37}
  - {wavelength: 0.60, data: 1.34}
  - {wavelength: 0.70, data: 1.30}
  - {wavelength: 0.80, data: 1.25}

# Media
- medium: &amp;air_medium
    refractive_index: 1
    extinction: *air_kabs

- medium: &amp;glass_medium
    refractive_index: *glass_ref_index
    extinction: *glass_kabs

# Sun &amp; atmosphere
- sun: {dni: 1, spectrum: *solar_spectrum}
- atmosphere: {extinction: *air_kabs}

# Materials
- material: &amp;specular {mirror: {reflectivity: 1, slope_error: 0}}
- material: &amp;black {matte: {reflectivity: 0}}
- material: &amp;glass
    front: {dielectric: {medium_i: *air_medium, medium_t: *glass_medium}}
    back:  {dielectric: {medium_i: *glass_medium, medium_t: *air_medium}}

# Primary reflectors
- entity:
    name: "primary_reflector1"
    primary: 1
    transform: {translation: [0, 0, -2.0]}
    geometry:
    - material: *specular
      parabol:
        focal: 12
        clip:
        - {operation: AND, circle: {radius: 10}}
        - {operation: SUB, circle: {radius: 5}}

- entity:
    name: "primary_reflector2"
    primary: 1
    transform: {translation: [0, 0, -4]}
    geometry:
    - material: *specular
      parabol:
        focal: 14
        clip:
        - {operation: AND, circle: {radius: 15}}
        - {operation: SUB, circle: {radius: 10}}

- entity:
    name: "primary_reflector3"
    primary: 1
    transform: {translation: [0, 0, -6]}
    geometry:
    - material: *specular
      parabol:
        focal: 16
        clip:
        - {operation: AND, circle: {radius: 20}}
        - {operation: SUB, circle: {radius: 15}}

# Secondary reflector
- entity:
    name: "secondary_reflector"
    primary: 0
    transform: {translation: [0, 0, 6]}
    geometry:
    - material: *specular
      hyperbol:
        focals: {real: 16.0, image: 4}
        clip: [{operation: AND, circle: {radius: 5}}]

# Glass box
- entity:
    name: "glass_slide"
    primary: 0 # The entity is not sampled as a primary reflector
    geometry:
    - material: *glass
      cuboid: {size: [10,10,0.5]}
      transform: {translation: [0, 0, 0.25]}

# Receiver
- entity:
    name: "square_receiver"
    primary: 0 # The entity is not sampled as a primary reflector
    transform: {translation: [0, 0, -10] }
    geometry:
    - material: *black
      plane:
        clip:
        - operation: AND
          vertices: [[-0.5,-0.5],[-0.5,0.5],[0.5,0.5],[0.5,-0.5]]</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_notes">NOTES</h2>
<div class="sectionbody">
<div class="olist arabic"><ol class="arabic">
<li>
<p>
YAML Ain&#8217;t Markup Language - <a href="http://yaml.org">http://yaml.org</a>
</p>
</li>
<li>
<p>
SMARTS, Simple Model of the Atmospheric Radiative Transfer of Sunshine -
   <a href="http://www.nrel.gov/rredc/smarts/">http://www.nrel.gov/rredc/smarts/</a>
</p>
</li>
<li>
<p>
D. Buie, A.G. Monger, C.J. Dey. "Sunshape distributions for
   terrestrial solar simulations". Solar Energy, 2003, 74, pp. 113-122.
</p>
</li>
<li>
<p>
D. Buie, C.J. Dey, S. Bosi. "The effective size of the solar cone for
   solar concentrating systems". Solar Energy, 2003, 74, pp. 417-427.
</p>
</li>
<li>
<p>
Portable PixMap - <a href="http://netpbm.sourceforge.net/doc/ppm.html">http://netpbm.sourceforge.net/doc/ppm.html</a>
</p>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">SEE ALSO</h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>solstice</strong>(1), <strong>solstice-receiver</strong>(5)</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-06-04 14:20:08 UTC
</div>
</div>
</body>
</html>
